import time
import json
from multiprocessing import Process, Manager
from selenium import webdriver

from arbitrage import find_arbitrage
from util import BookieSite
from fanduel import FanduelController
from draftkings import DraftKingsController

CONTROLLER_OBJ_MAP = {
    BookieSite.FANDUEL: FanduelController,
    BookieSite.DRAFTKINGS: DraftKingsController,
}


def thread_provisioner(bookie_site, shared_dict, key, event, bet_dict, controller):
    print(f'Thread {key} starting monitoring of {bookie_site}')
    controller.startup()
    controller.run_main_loop(shared_dict, event, bet_dict)


def monitor_website(bookie_site, website_url, shared_dict, event, bet_dict):
    """ TODO generated by chatgpt. Should be moved inside the respective other files for each website. Will need a way
            to reconcile all of the various monitor_websites, and call the correct one from the main"""
    # Initialize WebDriver
    driver = webdriver.Firefox()  # Or any other driver you prefer
    driver.get(website_url)

    # Setup phase
    # Here you should implement the login and navigation to the right page
    # ...

    while True:
        if event.is_set():
            # If the event is set, place a bet
            bet_details = bet_dict[bookie_site]

            # Here you should implement the function that places a bet
            # ...

            event.clear()  # Clear the event

            # After placing the bet, you can continue to the normal operation

        # Check for updates
        # ...

        # Compile information into JSON format
        data = {
            "sports": ...,  # Fill in the details
            "teams": ...,
            "odds": ...
        }

        # Write data to shared dictionary
        shared_dict[bookie_site] = json.dumps(data)

        time.sleep(1)  # You can adjust the sleep time as needed


def analyze_data(shared_dict, events_dict, bet_dicts, controller_dict):

    cur_serialized_mental_model = dict()

    while True:

        is_changed = False

        # Check for new keys
        dif_keys = set(shared_dict.keys()).difference(set(cur_serialized_mental_model.keys()))
        for dif_key in dif_keys:
            cur_serialized_mental_model[dif_key] = shared_dict[dif_key]
            is_changed = True

        # Check if there's any mis-match between the mental model and the shared_dict
        for key in cur_serialized_mental_model:
            if cur_serialized_mental_model[key] != shared_dict[key]:
                cur_serialized_mental_model[key] = shared_dict[key]
                is_changed = True

        # Only continue processing if there was a change to the shared_dict. Otherwise, restart the loop
        if is_changed:
            # Un-serialize the mental model
            mental_model = dict()
            for key in cur_serialized_mental_model:
                mental_model[key] = json.loads(cur_serialized_mental_model[key])

            print(mental_model)

            # all_arb_bets = find_arbitrage(mental_model)  TODO put this back
            all_arb_bets = [((BookieSite.DRAFTKINGS, 'kia tigers', '-111'), (BookieSite.FANDUEL, 'lg twins', '+125'))]  # TODO remove

            if len(all_arb_bets) > 0:
                # TODO trigger threads to place these bets. I need to make sure it can handle when len(all_arb_bets) > 1 and I need to place multiple bets on the same site
                x = 1

            # events_dict[BookieSite.FANDUEL].set()  # just for testing, remove later
            x = 1

            # ChatGPT generated from here on:
            """ TODO generated by chatgpt. Obvi need to implement the arbitrage analysis here, and figure out the exact
                    structure of the shared bet_dicts that will be used to communicate with the threads """

            # Read data from shared dictionary
            data = {key: json.loads(value) for key, value in shared_dict.items()}

            # Perform analysis
            # ...

            # Based on analysis, decide to trigger the betting
            # Let's assume that the result of the analysis is the index of the website to bet on
            # website_to_bet_on = ...
            # bet_details = {
            #     "team": ...,
            #     "sport": ...,
            #     "amount": ...
            # }

            # # Pass the bet details to the corresponding thread
            # bet_dicts[website_to_bet_on][website_to_bet_on] = bet_details
            #
            # # Set the event to signal the thread to place a bet
            # events[website_to_bet_on].set()
            #
            # time.sleep(1)


def main():
    target_sport = 'baseball'

    bookie_sites = list(BookieSite.__members__.values())

    with Manager() as manager:
        # Create shared dictionary
        shared_dict = manager.dict()

        # Create shared dictionaries for bet details
        bet_dict = manager.dict()

        # Create controller objects
        controller_objs = [CONTROLLER_OBJ_MAP[site](target_sport=target_sport) for site in bookie_sites]
        controller_dict = {k: v for k, v in zip(bookie_sites, controller_objs)}

        # Create events
        events_lst = [manager.Event() for _ in bookie_sites]
        events_dict = {k: v for k, v in zip(bookie_sites, events_lst)}

        # Create processes for provisioning threads
        processes = [Process(target=thread_provisioner, args=(site, shared_dict, i, event, bet_dict, controller)) for i, (site, event, controller) in enumerate(zip(bookie_sites, events_lst, controller_objs))]

        # Create process for analyzing data
        processes.append(Process(target=analyze_data, args=(shared_dict, events_dict, bet_dict, controller_dict)))

        # Start all processes
        for p in processes:
            p.start()

        # Wait for all processes to finish
        for p in processes:
            p.join()


if __name__ == "__main__":
    main()
